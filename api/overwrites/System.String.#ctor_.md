---
summary: Initializes a new instance of the <xref href="System.String"></xref> class.
remarks: "In this section:  \n  \n [Overloaded constructor syntax](#Syntax)   \n [Parameters](#Params)   \n [Exceptions](#Exceptions)   \n [Which method do I call?](#Tasks)   \n [Creating strings](#Creating_Strings)   \n [Handling repetitive strings](#Repetitive)   \n Examples of instantiating strings:   \n [Using string assignment](#Ctor1_Example)  \n [Using a character array](#Ctor2_Example)  \n [Using a portion of a character array and repeating a single character](#Ctor3_Example)  \n [Using a pointer to a character array](#Ctor4_Example)  \n [Using  a pointer and a range of an array](#Ctor5_Example)  \n [Using a pointer to a signed byte array](#Ctor6_Example)  \n[Version information](#Versions)  \n  \n<a name=\"Syntax\"></a>   \n## Overloaded constructor syntax  \n String constructors fall into two categories: those without pointer parameters, and those with pointer parameters. The constructors that use pointers are not CLS-compliant. In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context. For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  \n  \n For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)  \n  \n `String(Char[]`  `value` `)`  \n Initializes the new instance to the value indicated by an array of Unicode characters. This constructor copies Unicode characters([example](#Ctor2_Example)).  \n  \n `String(Char[]`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  \n Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).  \n  \n `String(Char`  `c` `, Int32`  `count` `)`  \n Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).  \n  \n `String(char*`  `value` `)`  \n **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\\0'). ([example](#Ctor4_Example)).  \n  \n Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.  \n  \n `String(char*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  \n **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length. The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` – 1 ([example](#Ctor5_Example)).  \n  \n Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.  \n  \n `String(SByte*`  `value` `)`  \n **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers. The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=fullName>). The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).  \n  \n Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.  \n  \n `String(SByte*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  \n **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.  The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=fullName>). The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` – 1 ([example](#Ctor6_Example)).  \n  \n Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.  \n  \n `String(SByte*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `, Encoding`  `enc` `)`  \n **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.  \n  \n Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.  \n  \n<a name=\"Params\"></a>   \n## Parameters  \n Here is a complete list of parameters used by <xref:System.String>constructors that do not include a pointer parameter. For the parameters used by each overload, see the overload syntax above.  \n  \n|Parameter|Type|Description|  \n|---------------|----------|-----------------|  \n|`value`|<xref:System.Char>[]|An array of Unicode characters.|  \n|`c`|<xref:System.Char>|A Unicode character.|  \n|`startIndex`|<xref:System.Int32>|The starting position in `value` of the first character in the new string.<br /><br /> Default value: 0|  \n|`length`|<xref:System.Int32>|The number of characters in `value` to include in the new string.<br /><br /> Default value: <xref:System.Array.Length%2A?displayProperty=fullName>|  \n|`count`|<xref:System.Int32>|The number of times the character `c` is repeated in the new string. If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=fullName>.|  \n  \n Here is a complete list of parameters used by <xref:System.String>constructors that include a pointer parameter. For the parameters used by each overload, see the overload syntax above.  \n  \n|Parameter|Type|Description|  \n|---------------|----------|-----------------|  \n|`value`|<xref:System.Char>*<br /><br /> -or-<br /><br /> <xref:System.SByte>\\*|A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers. If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=fullName>.|  \n|`startIndex`|<xref:System.Int32>|The index of the array element that defines the first character in the new string.<br /><br /> Default value: 0|  \n|`length`|<xref:System.Int32>|The number of array elements to use to create the new string. If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=fullName>.<br /><br /> Default value: <xref:System.Array.Length%2A?displayProperty=fullName>|  \n|`enc`|<xref:System.Text.Encoding>|An object that specifies how the `value` array is encoded.<br /><br /> Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=fullName>, or the system's current ANSI code page|  \n  \n<a name=\"Exceptions\"></a>   \n## Exceptions  \n Here's a list of exceptions thrown by constructors that do not include pointer parameters.  \n  \n|Exception|Condition|Thrown by|  \n|---------------|---------------|---------------|  \n|<xref:System.ArgumentNullException>|`value` is `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  \n|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, or `count` is less than zero.<br /><br /> -or-<br /><br /> The sum of `startIndex` and `length` is greater than the number of elements in `value`.<br /><br /> -or-<br /><br /> `count` is less than zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  \n  \n Here's a list of exceptions thrown by constructors that include pointer parameters.  \n  \n|Exception|Condition|Thrown by|  \n|---------------|---------------|---------------|  \n|<xref:System.ArgumentException>|`value` specifies an array that contains an invalid Unicode character.<br /><br /> -or-<br /><br /> `value` or `value` + `startIndex` specifies an address that is less than 64K.<br /><br /> -or-<br /><br /> A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.|All constructors with pointers.|  \n|<xref:System.ArgumentNullException>|`value` is null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  \n|<xref:System.ArgumentOutOfRangeException>|The current process does not have read access to all the addressed characters.<br /><br /> -or-<br /><br /> `startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.<br /><br /> -or-<br /><br /> The length of the new string is too large to allocate.|All constructors with pointers.|  \n|<xref:System.AccessViolationException>|`value`, or `value` + `startIndex` + `length` – 1, specifies an invalid address.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  \n  \n<a name=\"Tasks\"></a>   \n## Which method do I call?  \n  \n|To|Call or use|  \n|--------|-----------------|  \n|Create a string.|Assignment from a string literal or an existing string ([example](#Ctor1_Example))|  \n|Create a string from an entire character array.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))|  \n|Createa string from a portion of a character array.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))|  \n|Create a string that repeats the same character multiple times.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))|  \n|Create a string from a pointer to a Unicode or wide character array.|<xref:System.String.%23ctor%28System.Char%2A%29>|  \n|Create a string from a portion of a Unicode or wide character array by using its pointer.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  \n|Create a string from a C++ `char` array.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> -or-<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  \n|Create a string from ASCII characters.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=fullName>|  \n  \n<a name=\"Creating_Strings\"></a>   \n## Creating strings  \n The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example). The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:  \n  \n-   From a character array (an array of UTF-16-encoded characters). You can create a new <xref:System.String> object from the characters in the entire array or a portion of it. The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string. The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` – 1 to the new string. If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=fullName>.  \n  \n     If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings. For more information, see [Handling repetitive strings](#Repetitive).  \n  \n-   From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor. If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=fullName>.  \n  \n-   From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor. Either the entire array or a specified range can be used to initialize the string. The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters. If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=fullName>. If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent. Such a condition might cause an access violation.  \n  \n     If the array contains any embedded null characters (U+0000 or '\\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls. The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method. Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls. On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.  \n  \n     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]\n     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  \n  \n     The array must contain Unicode characters. In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.  \n  \n     If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur. In addition, on the Intel Itanium processor, calls to the<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>constructor may throw a <xref:System.DataMisalignedException> exception. If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.  \n  \n-   From a pointer to a signed byte array. Either the entire array or a specified range can be used to initialize the string. The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call. If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.  \n  \n     The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:  \n  \n     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  \n  \n     If the array contains any null characters ('\\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls. The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method. Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls. On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.  \n  \n     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]\n     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  \n  \n     Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.  \n  \n<a name=\"Repetitive\"></a>   \n## Handling repetitive strings  \n Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method to convert sequences of characters into a string. Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory. If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you do not know in advance what those identical string values may be, you can use a lookup table instead.  \n  \n For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes. When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning). Tokens equivalent to the strings \"0\", \"1\", \"true\", and \"false\" are likely to occur frequently in an XML stream.  \n  \n Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=fullName> object to hold commonly occurring strings. The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory. When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method to retrieve the token from the table. If the token exists, the method returns the corresponding string. If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method to insert the token into the table and to get the corresponding string.  \n  \n<a name=\"Ctor1_Example\"></a>   \n## Example 1: Using string assignment  \n The following example creates a new string by assigning it a string literal. It creates a second string by assigning the value of the first string to it. These are the two most common ways to instantiate a new <xref:System.String> object.  \n  \n [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]\n [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]\n [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  \n  \n<a name=\"Ctor2_Example\"></a>   \n## Example 2: Using a character array  \n The following example demonstrates how to create a new <xref:System.String> object from a character array.  \n  \n [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]\n [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]\n [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  \n  \n<a name=\"Ctor3_Example\"></a>   \n## Example 3: Using a portion of a character array and repeating a single character  \n The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.  \n  \n [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]\n [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]\n [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  \n  \n<a name=\"Ctor4_Example\"></a>   \n## Example 4: Using a pointer to a character array  \n The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters. The C# example must be compiled by using the `/unsafe` compiler switch.  \n  \n [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]\n [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  \n  \n<a name=\"Ctor5_Example\"></a>   \n## Example 5: Instantiating a string from a pointer and a range of an array  \n The following example examines the elements of a character array for either a period or an exclamation point. If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol. If not, it instantiates a string with the entire contents of the array. The C# example must be compiled using the `/unsafe` compiler switch.  \n  \n [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]\n [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  \n  \n<a name=\"Ctor6_Example\"></a>   \n## Example 6: Instantiating a string from a pointer to a signed byte array  \n The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.  \n  \n [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]\n [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  \n  \n<a name=\"Versions\"></a>   \n## Version information  \n .NET Framework  \n All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  \n  \n .NET Framework Client Profile  \n All overloads are supported in: 4, 3.5 SP1  \n  \n Portable Class Library  \n All overloads without an <xref:System.SByte>`*` parameter are supported  \n  \n .NET for Windows Store apps  \n All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8"
uid: System.String.#ctor*
---
